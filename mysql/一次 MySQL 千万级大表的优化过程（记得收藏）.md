作者： IT技术分享

链接：toutiao.com/a6716289605294883340

**方案概述**

- 方案一：优化现有MySQL数据库。优点：不影响现有业务，源程序不需要修改代码，成本最低。缺点：有优化瓶颈，数据量过亿就玩完了。
- 方案二：升级数据库类型，换一种100%兼容MySQL的数据库。优点：不影响现有业务，源程序不需要修改代码，你几乎不需要做任何操作就能提升数据库性能，缺点：多花钱。
- 方案三：一步到位，大数据解决方案，更换newSQL/noSQL数据库。优点：没有数据容量瓶颈，缺点：需要修改源程序代码，影响业务，总成本最高。

![img](image\一次 MySQL 千万级大表的优化过程（记得收藏）\640.webp)



**优化现有MySQL数据库**

**数据库设计**

- 表字段避免null值出现，null值很难查询优化且占用额外的索引空间，推荐默认数字0代替null。
- 尽量使用INT而非BIGINT，如果非负则加上UNSIGNED（这样数值容量会扩大一倍），当然能使用TINYINT、SMALLINT、MEDIUM_INT更好。
- 使用枚举或整数代替字符串类型。
- 尽量使用TIMESTAMP而非DATETIME。
- 单表不要有太多字段，建议在20以内。
- 用整型来存IP。



**索引设计**

- 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描。
- 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描。
- 值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段。
- 字符字段只建前缀索引。
- 字符字段最好不要做主键。
- 不用外键，由程序保证约束。
- 尽量不用UNIQUE，由程序保证约束。
- 使用多列索引时注意顺序和查询条件保持一致，同时删除不必要的单列索引。
- 使用可存下数据的最小的数据类型，整型 < date,time < char,varchar < blob*
- 使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int类型存储时间类型，bigint类型转ip函数。
- 使用合理的字段属性长度，固定长度的表会更快。使用enum、char而不是varchar。
- 尽可能使用not null定义字段。
- 尽量少用text，非用不可最好分表。
- 查询频繁的列，在where，group by，order by，on从句中出现的列。
- where条件中<，<=，=，>，>=，between，in，以及like 字符串+通配符（%）出现的列。
- 长度小的列，索引字段越小越好，因为数据库的存储单位是页，一页中能存下的数据越多越好。
- 离散度大（不同的值多）的列，放在联合索引前面。查看离散度，通过统计不同的列值来实现，count越大，离散程度越高。



![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**SQL编写**

- 使用limit对查询结果的记录进行限定。
- 避免select *，将需要查找的字段列出来。
- 使用连接（join）来代替子查询。
- 拆分大的delete或insert语句。
- 可通过开启慢查询日志来找出较慢的SQL。
- 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边。
- SQL语句尽可能简单：一条SQL只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大SQL可以堵死整个库。
- OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内。
- 不用函数和触发器，在应用程序实现。
- 避免%xxx式查询。
- 少用JOIN。
- 使用同类型进行比较，比如用'123'和'123'比，123和123比。
- 尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
- 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5。
- 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大。



![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**分区**

- 可以让单表存储更多的数据。
- 分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作。
- 部分查询能够从查询条件确定只落在少数分区上，速度会很快。
- 分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备。
- 可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争。
- 可以备份和恢复单个分区。
- 一个表最多只能有1024个分区。
- 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
- 分区表无法使用外键约束。
- NULL值会使分区过滤无效。
- 所有分区必须使用相同的存储引擎。



**分表**

- 分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。
- 分表分为垂直拆分和水平拆分，通常以某个字段做拆分项。比如以id字段拆分为100张表：表名为 tableName_id%100。
- 但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高！！！而且选择这个方案，都不如选择我提供的第二第三个方案的成本低！故不建议采用。



**分库**

- 把一个数据库分成多个，建议做个读写分离就行了，真正的做分库也会带来大量的开发成本，得不偿失！不推荐使用。

------



**升级数据库**

- 开源数据库会带来大量的运维成本且其工业品质和MySQL尚有差距，有很多坑要踩，如果你公司要求必须自建数据库，那么选择该类型产品。如tiDB pingcap/tidb，Cubrid Open Source Database With Enterprise Features。
- 阿里云POLARDB，POLARDB 是阿里云自研的下一代关系型分布式云原生数据库，100%兼容MySQL，存储容量最高可达 100T，性能最高提升至 MySQL 的 6 倍。POLARDB 既融合了商业数据库稳定、可靠、高性能的特征，又具有开源数据库简单、可扩展、持续迭代的优势，而成本只需商用数据库的 1/10。
- 阿里云OcenanBase，淘宝使用的，扛得住双十一，性能卓著，但是在公测中，我无法尝试，但值得期待。
- 阿里云HybridDB for MySQL (原PetaData)，云数据库HybridDB for MySQL （原名PetaData）是同时支持海量数据在线事务（OLTP）和在线分析（OLAP）的HTAP（Hybrid Transaction/Analytical Processing）关系型数据库。
- 腾讯云DCDB，DCDB又名TDSQL，一种兼容MySQL协议和语法，支持自动水平拆分的高性能分布式数据库——即业务显示为完整的逻辑表，数据却均匀的拆分到多个分片中；每个分片默认采用主备架构，提供灾备、恢复、监控、不停机扩容等全套解决方案，适用于TB或PB级的海量数据场景。

------



**换大数据引擎**

- hadoop家族。hbase/hive怼上就是了。但是有很高的运维成本，一般公司是玩不起的，没十万投入是不会有很好的产出的！
- 我选择了阿里云的MaxCompute配合DataWorks，使用超级舒服，按量付费，成本极低。
- MaxCompute可以理解为开源的Hive，提供SQL/mapreduce/ai算法/python脚本/shell脚本等方式操作数据，数据以表格的形式展现，以分布式方式存储，采用定时任务和批处理的方式处理数据。DataWorks提供了一种工作流的方式管理你的数据处理任务和调度监控。
- 当然你也可以选择阿里云hbase等其他产品，我这里主要是离线处理，故选择MaxCompute，基本都是图形界面操作，大概写了300行SQL，费用不超过100块钱就解决了数据处理问题。